## 자료구조 & 알고리즘

<details>
<summary>📚 공부한 자료</summary>

- 파이썬 알고리즘 인터뷰

</details>

### **1. 시간복잡도와 공간복잡도에 대해 설명해 주세요.**

- **Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.**
- **다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?**
- **O(1)은 O(N^2) 보다 무조건적으로 빠른가요?**

### **2. 링크드 리스트에 대해 설명해 주세요.**

- **일반 배열과, 링크드 리스트를 비교해 주세요.**
- **링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명해 주세요.**

### **3. 스택과 큐에 대해서 설명해 주세요.**

- **스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도에 대해 설명해 주세요.**
- **시간복잡도를 유지하면서, 배열로 스택과 큐를 구현할 수 있을까요?**
- **Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산/하는 방법에 대해 설명해 주세요.**
- **Deque는 어떻게 구현할 수 있을까요?**
- **(C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?**

### **4. 해시 자료구조에 대해 설명해 주세요.**

- **값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?**
- **해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?**
- **본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?**
- **Double Hashing 의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.**
- **Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?**
- **다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.**

### **5. 트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.**

- **그래프와 트리의 차이가 무엇인가요?**
- **이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?**
- **이진탐색트리의 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.**
- **이진탐색트리의 한계점에 대해 설명해주세요.**
- **이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤식으로 값을 삽입하면 편향이 발생할까요?**
- **이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유에 대해 설명해 주세요.**

### **6. 힙에 대해 설명해 주세요.**

- 힙은 완전 이진 트리(Complete Binary Tree)의 일종으로, 부모 노드와 자식 노드 간에 특정한 조건을 만족하는 자료구조를 의미한다. 여기서 완전 이진 트리란 부모 노드 밑에 자식 노드가 최대 2개까지 있을 수 있고, 마지막 레벨을 제외한 모든 레벨에 노드가 완전히 채워져있는 트리 구조를 의미합니다.
힙에는 Max-heap, Min-heap 2가지가 있다. Max heap(최대 힙)은 모든 부모 노드가 자식 노드보다 크거나 같은 값을 갖는 특성을 의미한다. 이러한 특성 때문에 루트 노드는 전체 힙 중에서 가장 큰 값을 갖는다.
반대로 최소 힙은 모든 부모 노트가 자식 노드보다 작거나 같다. 그리고 트리의 루트 노드는 전체 힙 중에서 가장 작은 값을 갖는다.

- **힙을 배열로 구현한다고 가정하면, 어떻게 값을 저장할 수 있을까요?**
  - 답변: 루트 노드를 인덱스 1번에 저장, 부모 노드가 인덱스 i에 있다고 하면, 왼쪽 자식은 `2*i`, 오른쪽 자식은 `2*i+1`에 위치하도록 구현할 수 있다.

- **힙의 삽입, 삭제 방식에 대해 설명하고, 왜 이진탐색트리와 달리 편향이 발생하지 않는지 설명해 주세요.**

- Min heap을 기준으로 설명 
  - 힙의 삽입: 새로 들어온 노드를 배열의 맨 뒤에 넣고, 부모 노드로 거슬러 올라가면서 부모노드가 자신보다 크다면 자신과 위치를 바꾼다. 부모 노드가 나보다 작거나 같은 시점까지 이를 반복한다(상향식 heapify). 이때의 시간 복잡도는 O(logN)
  - 힙의 삭제: 루트 노드를 꺼내고, 배열에 맨 뒤에 있는 노드를 루트 노드에 넣는다. 그리고 루트노드부터 자식 노드 2개와 같을 비교해서 자신이 더 크다면 그 자식 노드와 자리를 바꾼다. 만약 두 자식이 부모 노드보다 다 작다면 두 자식 노드 중에서 더 작은 노드와 부모노드를 바꾼다. 이를 자식 노드가 모두 나보다 클때까지 반복한다(하향식 heapify). 
- 이진탐색트리와 달리 편향이 발생하지 않는 이유: 이진탐색트리와 달리 편향이 발생하지 않는 이유는 힙은 삽입을 할때는 배열에 맨 뒤에 삽입하여 상향식 heapify를, 삭제시에는 맨위 노드 자리에 배열에 맨 끝에 있는 요소를 가져와 넣어서 하향식 heapify를 하는 삽입, 삭제 방식 때문이다. 이 방식 때문에 항상 편향되지 않은 완전이진탐색트리의 구조를 유지한다.

- **힙 정렬의 시간복잡도는 어떻게 되나요? Stable 한가요?**
  - 답변: O(NlogN). 최초 build_heap에서 O(N)의 시간 복잡도가 걸리고, 원소를 삭제하면서 정렬하는데 O(NlogN)이 걸리기 때문이다. Heap Sort는 불안정정렬(Unstable Sort)이다. 안정 정렬이란 같은 값을 가지는 원소들의 순서가 정렬 이전과 이후에도 유지되는 것을 의미한다. 예를들어 [2, 1, 3, 2, 3]이런 배열이 있다면 앞에 있는 2는 정렬후에도 첫번째 2여야하고 뒤에 있는 2는 정렬 후에도 두번째 2여야한다. 힙정렬은 이를 보장하지 않는 Unstable 정렬이다.

### **7. BBST (Balanced Binary Search Tree) 와, 그 종류에 대해 설명해 주세요.**

  - Balanced Binary Search Tree(=균형 이진 탐색 트리): 왼쪽 서브트리와 오른쪽 서브트리의 height 차이가 1 이하인 이진 트리를 의미한다. 노드가 삽입/삭제 되더라도 왼쪽, 오른쪽 서브트리의 높이차이가 1 이하를 유지해야한다.

  #### red-black tree:
    - 루트와 모든 마지막 노드(null, leaf, NIL)는 블랙이다.
    - 레드 노드의 양쪽 자식은 언제나 블랙이다.(=레드는 연달아 나올 수 없고, 항상 블랙이 부모이다.)
    - 어떤 노드에서 시작해서 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 같은 개수의 블랙노드를 가지고 있다. (리프노드 자신은 제외)

    - 이러한 규칙을 이용하여 [루트 ~ 가장 먼 곳]의 거리가 [루트 ~ 가장 가까운 곳]의 두 배보다 작게 이진트리를 구성한다. 즉 시간복잡도가 트리의 깊이에 따라 결정되므로 트리의 삽입, 삭제, 검색 기능을 일정하게 유지시킨다.

#### AVL tree:
  - 



- **Red Black Tree는 어떻게 균형을 유지할 수 있을까요?**

- **Red Black Tree의 주요 성질 4가지에 대해 설명해 주세요.**
- **2-3-4 Tree, AVL Tree 등의 다른 BBST 가 있음에도, 왜 Red Black Tree가 많이 사용될까요?**


### **8. 정렬 알고리즘에 대해 설명해 주세요.**

- **Quick Sort와 Merge Sort를 비교해 주세요.**
- **Quick Sort에서 O(N^2)이 걸리는 예시를 들고, 이를 개선할 수 있는 방법에 대해 설명해 주세요.**
- **Stable Sort가 무엇이고, 어떤 정렬 알고리즘이 Stable 한지 설명해 주세요.**
- **Merge Sort를 재귀를 사용하지 않고 구현할 수 있을까요?**
- **Radix Sort에 대해 설명해 주세요.**
- **Bubble, Selection, Insertion Sort의 속도를 비교해 주세요.**
- **값이 거의 정렬되어 있거나, 아예 정렬되어 있다면, 위 세 알고리즘의 성능 비교 결과는 달라질까요?**
- **본인이 사용하고 있는 언어에선, 어떤 정렬 알고리즘을 사용하여 정렬 함수를 제공하고 있을까요?**
- **정렬해야 하는 데이터는 50G 인데, 메모리가 4G라면, 어떤 방식으로 정렬을 진행할 수 있을까요?**

### **9. 그래프 자료구조에 대해 설명하고, 이를 구현할 수 있는 두 방법에 대해 설명해 주세요.**

- **각 방법에 대해, "두 정점이 연결되었는지" 확인하는 시간복잡도와 "한 정점에 연결된 모든 정점을 찾는" 시간복잡도, 그리고 공간복잡도를 비교해 주세요.**
- **정점의 개수가 N개, 간선의 개수가 N^3 개라면, 어떤 방식으로 구현하는 것이 효율적일까요?**
- **사이클이 없는 그래프는 모두 트리인가요? 그렇지 않다면, 예시를 들어주세요.**

### **10. 그래프에서, 최단거리를 구하는 방법에 대해 설명해 주세요.**

- **트리에서는 어떤 방식으로 최단거리를 구할 수 있을까요? (위 방법을 사용하지 않고)**
- **다익스트라 알고리즘에서, 힙을 사용하지 않고 구현한다면 시간복잡도가 어떻게 변화할까요?**
- **정점의 개수가 N개, 간선의 개수가 N^3 개라면, 어떤 알고리즘이 효율적일까요?**
- **A\* 알고리즘에 대해 설명해 주세요. 이 알고리즘은 다익스트라와 비교해서 어떤 성능을 낼까요?**
- **음수 간선이 있을 때와, 음수 사이클이 있을 때 각각 어떤 최단거리 알고리즘을 사용해야 하는지 설명해 주세요.**

### **11. 재귀함수에 대해 설명해 주세요.**

- **재귀 함수의 동작 과정을 Call Stack을 활용해서 설명해 주세요.**
- **언어의 스펙에 따라, 재귀함수의 최적화를 진행해주는 경우가 있습니다. 어떤 경우에 재귀함수의 최적화가 가능하며, 이를 어떻게 최적화 할 수 있을지 설명해 주세요.**

### **12. MST가 무엇이고, 어떻게 구할 수 있을지 설명해 주세요.**

- **Kruskal 알고리즘에서 사용하는 Union-Find 자료구조에 대해 설명해 주세요.**
- **Kruskal 과 Prim 중, 어떤 것이 더 빠를까요?**
- **Kruskal 과 Prim 알고리즘을 통해 얻어진 결과물은 무조건 트리인가요? 만약 그렇다면 증명해 주세요. 그렇지 않다면, 반례를 설명해 주세요.**

### **13. Thread Safe 한 자료구조가 있을까요? 없다면, 어떻게 Thread Safe 하게 구성할 수 있을까요?**

- **배열의 길이를 알고 있다면, 조금 더 빠른 Thread Safe 한 연산을 만들 순 없을까요?**
- **사용하고 있는 언어의 자료구조는 Thread Safe 한가요? 그렇지 않다면, Thread Safe 한 Wrapped Data Structure 를 제공하고 있나요?**

### **14. 문자열을 저장하고, 처리하는 주요 자료구조 및 알고리즘 (Trie, KMP, Rabin Karp 등) 에 대해 설명해 주세요.**

### **15. 이진탐색이 무엇인지 설명하고, 시간복잡도를 증명해 보세요.**

- **Lower Bound, Upper Bound 는 무엇이고, 이를 어떻게 구현할 수 있을까요?**
- **이진탐색의 논리를 적용하여 삼진탐색을 작성한다고 가정한다면, 시간복잡도는 어떻게 변화할까요? (실제 존재하는 삼진탐색 알고리즘은 무시하세요!)**
- **기존 이진탐색 로직에서 부등호의 범위가 바뀐다면, (ex. <= 라면 <로, <이라면 <= 로) 결과가 달라질까요?**

### **16. 그리디 알고리즘과 동적 계획법을 비교해 주세요.**
- 동적 계획법: 문제의 일부분을 풀고 그 결과를 재활용하는 방법이다. 하나의 문제를 **중복되는 서브 문제**로 나누어 푼다.
- 그리디: DP가 중복되는 서브 문제를 다뤘다면, 그리디는 **중복되지 않는 서브 문제**를 다룬다. 그리디 알고리즘은 발견법(휴리스틱 메소드, 최적의 답을 찾기보다 주어진 상황을 한단계씩 빠른 시간 내에 해결하기 위해 사용하는 방법론) 중 하나이다. 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미

- DP와 greedy의 공통점은 최적 부분 구조 문제를 푸는 방법에서 비교된다. DP는 문제를 작은 단위로 분할한 뒤, 해결한 서브 문제들의 결과를 기반으로 전체 문제를 푼다. 그리디는 각 단계마다의 최적해, 즉 각 단계마다의 최적의 방법을 선택하면서 문제를 푼다.

- **그렇다면, 어떤 경우에 각각의 기법을 사용할 수 있을까요?**
  - Greedy: 문제의 각 단계에서의 최적의 선택이 전체 문제의 최적해를 보장할때. 동전 거스름돈 문제, 크루스칼 알고리즘 등
  - DP: 문제를 작은 부분 문제로 나눌 수 있으며, 부분 문제의 해결이 반복되어서 중복 계산이 많이 발생할 때 사용가능. 피보나치 수열, 0-1 냅색, LCS 등
- **그렇다면, 동적 계획법으로 풀 수 있는 모든 문제는 재귀로 변환하여 풀 수 있나요?**
  - 풀 수 있다. 하지만 Stack Overflow 문제를 발생시킬 수 있다. 마찬가지로 모든 재귀로 해결할 수 있는 문제는 재귀함수를 사용하지 않고도 풀 수 있다.
