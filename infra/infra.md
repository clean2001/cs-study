## Infra

### **1. 가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.**

- **그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?**
- **하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?**
- **Docker 위에 Docker를 올릴 순 없을까요?**
- **Docker Engine 은 무엇인가요?**

### **2. CI/CD 를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.**

### **3. Web Server, Web Application Server 의 차이는 무엇인가요?**

  답변:
  웹서버
    
  - 웹 서버는 **정적인 콘텐츠**(HTML, CSS, 이미지)등을 제공하는 서버이다.
  - HTTP 프로토콜을 이용해 클라이언트에게 웹 페이지를 제공한다.
  - 웹 서버의 임무는 크게 두가지이다. 첫번째는 단순히 저장된 웹 리소스들을 클라이언트로 전달하고, 클라이언트로부터 콘텐츠를 전달받아 저장하거나 처리한다.
  - 사용자로부터 동적인 요청이 들어왔을때, 해당 요청을 웹서버 자체에서 처리하기 어렵기에 WAS에게 요청한다.
  - Apache, Nginx가 대표적이다.

  WAS(Web Application Server)
  - **동적인 컨텐츠**(웹 애플리케이션)을 처리하고 제공하는 서버이다.
  - 웹 애플리케이션 실행 및 데이터 처리, 웹 서버와 클라이언트 간의 중계 역할을 한다. 웹 애플리케이션을 실행하여 동적 콘텐츠를 생성하고 웹 서버와 클라이언트 간의 데이터 처리를 담당하는 역할을 한다. 즉, WAS 서버는 클라이언트의 요청에 따라 데이터베이스에서 정보를 가져오거나, 웹 애플리케이션을 실행하여 동적인 웹 페이지를 생성한 후 결과를 웹 서버에 전달한다. 웹 서버는 이를 받아 클라이언트에게 전달한다.
  - 톰캣이 대표적이다.



  WAS와 웹 서버를 효율적으로 사용하는 방법
      
   WAS는 DB 조회 등 다양한 로직을 처리하는데에 집중해야한다. 따라서 단순한 정적 콘텐츠는 웹 서버에게 맡기고 기능을 분리해서 서버부하를 방지해야한다.
   WAS가 정적 콘텐츠 요청까지 처리하게 되면, 부하가 커지고 동적 콘텐츠 처리가 지연되면서 수행 속도가 느려진다. 이러면 페이지 노출시간이 늘어나는 문제가 발생하게 된다.
     따라서 웹 서버를 앞단에 두고, WAS는 웹 서버가 처리하기 힘든 서버 사이드 코드의 로직을 수행하면 효율적으로 WAS와 Web Server를 활용할 수 있다.


### 4. Git에 대해 설명해 주세요.
  - 답변: git이란 분산 버전 관리 시스템(Distributed Version Control System)이다. 컴퓨터 파일의 변경사항을 추적하고 여러명의 사용자들 간의 파일에 대한 작업을 조율하는 데 사용된다. 즉, 주로 여러명의 개발자가 하나의 소프트웨어 개발 프로젝트에 참여할 때, 소스코드의 버전을 관리하는 데 주로 사용된다.

#### 깃의 구조
- Repository: 저장소. 저장소는 히스토리, 태그, 소스의 가지치기 혹은 branch에 따라 버전을 저장한다. 작업자가 변경한 모든 히스토리를 확인 가능하다.
- Working Directory : 저장소를 어느 한 시점을 바라보는 작업자의 현재 시점이다. Working Directory(Workspace)에서 작업 후 새로운 버전이 될 후보군은 Staging Area로 이동한다.
- Staging Area: 이 단계에서는 Local Repository로 파일을 넣기 위한 대상 목록이 관리된다. 로컬 저장소로 넣으면 그때부터 이력이 생성된다.
- 로컬 저장소(local repo): 커밋을 하면 로컬 리포지토리에 저장되며 새로운 버전이 생성된다. 이때 staging area는 비워지게 된다.
- 원격 저장소(remote repo): push하면 local repo에 저장된 내용이 원격 저장소에 반영된다.

#### git fetch와 git pull의 차이점
- git fetch: origin 데이터를 로컬로 가져오되 병헙은 하지 않음. 즉 remote repo의 내용을 local repo까지는 가져오지만 staging area와 working directory에는 반영하지 않는다. 즉, 머지는 하지 않기 때문에 충돌이 발생하지 않는다.
- git pull: remote repo의 수정사항을 working directory까지 가져오며 머지한다. 머지시에 충돌이 생길 가능성이 있다.

- **여러 브랜치를 합쳐야 할 때, 어떤 방법을 사용할 수 있는지 "모두" 설명해 주세요.**

#### merge 전략
- merge: 두 브랜치의 변경을 통합하는 가장 기본적인 방법이다. 서브 브랜치에 있는 commit Id들과 merge할때 생기는 merge commitID가 main 브랜치에 남게 된다.
- rebase merge: 한 브랜치의 커밋을 다른 브랜치의 최신 커밋에 재적용하는 방식이다. 이때에는 브랜치에서 넘어온 commitID가 아닌 새로운 commitID가 발급되어 메인브랜치에 남게된다. 장점은 merge commitID가 남지 않게되어 불필요한 커밋 없이 깔끔하게 커밋이 관리된다. 단점은 commit history는 유지되지만, 모든 커밋아이디가 변경돼서 main에 반영되므로 동일 브랜치에서 재PR시에 충돌이 발생한다. 따라서 한번 머지된 브랜치는 재사용이 불가능하다.
- squash merge: squash는 여러 커밋을 하나의 커밋으로 합치는 과정이다. local repository에서 여러 커밋을 발생시켰을 때, 해당 커밋 ID를 통합하여 하나의 commitID로 만들어서 main에는 하나의 커밋이력으로 남게된다. squash merge또한 이미 머지된 브랜치의 재사용은 불가능하다.
- cherry pick: dev에서 채번된 branch1, branch2가 모두 dev에 머지돼있을 때, branch1만 main으로 머지하고 싶은 상황. 즉 특정 커밋이력만 pick해서 머지하는 것이 cherry pick이다. 문제점은 기존의 commitID 체리픽을 통해 main merge된 이후 생성된 commitID가 일치하지 않는 경우 추후 dev 전체를 main에 머지할 때 충돌이 발생한다.