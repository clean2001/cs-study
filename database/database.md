### **1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.**
  Answer:
    - 기본키: 후보키들 중에서 하나를 선택한 것으로 테이블에서 한개이며 최소성과 유일성을 만족합니다. NULL을 가질 수 없습니다.
    - 슈퍼키: 어떤 레코드를 유일하게 특정할 수 있는 하나의 칼럼 또는 여러개의 칼럼 집합을 의미합니다. 유일성을 만족합니다.
    - 후보키: 기본키가 될 수 있는, 유일성, 최소성을 만족하는 키 집합입니다.
    - 대체키: 기본키로 선정되지 않은 후보키들을 대체키라고 합니다.

- **기본키는 수정이 가능한가요?**
  Answer: 수정이 가능하지만 유일한 값이어야 합니다.
- **사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?**
  Answer: 
    Mysql은 기본키를 설정하지 않고 테이블을 만든다면 자체적으로 테이블 속성 중에 null 값이 없고, 각 레코드마다 유일한 값을 갖는 첫 속성을 골라 클러스터형 인덱스로 지정합니다. 만약 적절한 칼럼이 존재하지 않는다면 InnoDB가 자체적으로 클러스터형 인덱스를 생성합니다.
      출처: https://velog.io/@becooq81/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4
- **외래키 값은 NULL이 들어올 수 있나요?**
  Answer: 들어올 수 있습니다.
- **어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?**
  Answer: 처음에 값을 추가할 때는 전체 칼럼을 검색해야하기 때문에 느립니다. 하지만 이후에는 유일성이 보장되기 때문에 빠르게 검색할 수 있습니다.

### **2. RDB와 NoSQL의 차이에 대해 설명해 주세요.**

- 답변:
    - RDB: 관계형 데이터베이스는 사전에 엄격하게 정의된 DB schema를 요구하는 table 기반의 구조를 갖는다. 엄격한 스키마로 인해 데이터 중복이 없기 때문에 데이터 update가 많을 때 유리하다. 트랜잭션에서 ACID의 성질을 통해 데이터 무결성을 보장한다. 
    - NoSQL: table 형식이 아닌 비정형 데이터를 저장할 수 있도록 지원한다. 데이터의 중복으로 인해 update 시 모든 컬렉션에서 수정이 필요하기에 update가 적고 조회가 많을 때 유리하다. BASE의 특성을 통해 데이터의 무결성보다는 성능을 중시한다.
      - Basically Available: 시스템이 항상 사용/접근 가능해야한다.
      - Soft state: 외부의 개입 없이도 상태(데이터)가 바뀔 수 있다. 즉, 데이터의 일시적인 불일치를 허용한다.
      - Eventually Consistent: 일정 시간 경과 시 데이터의 일관성이 유지된다.

- **NoSQL의 강점과, 약점이 무엇인가요?**
  - 강점: 유연하고 자유로운 데이터 구조, 새로운 필드 추가가 자유롭다, 수평적 확장(scale out)이 용이하다.
  - 약점: 데이터 중복 발생 가능, 중복 데이터가 많아 데이터 변경 시 모든 컬렉션에서 수정 필요, 명확한 데이터 구조가 보장되지 않는다. 데이터 정합성이 일시적으로 깨질 수 있다.

- **RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)**
  - 답변: 정규화된 스키마, 트랜잭션, 수평적 확장의 어려움 등이 NoSQL에 비해 부하가 많이 걸릴 수 있는 요인이다.
    - 정규화된 스키마: RDB는 데이터 정규화를 통해 중복을 최소화하고 데이터의 일관성을 유지한다. 하지만 이로 인해서 데이터 조회 시, 여러 테이블을 조인해야하는데 이러한 조인연산은 성능에 부하를 줄 수 있다.
    - 트랜잭션: RDB는 트랜잭션을 지원하여 데이터의 일관성과 무결성을 보장한다. 하지만 트랜잭션 처리에는 추가적인 오버헤드가 따르며 동시에 여러 트랜잭션이 처리되는 상황에서 락으로 인해 동시 접근이 제한되며 성능 저하가 발생할 수 있다.
    - 수평적 확장의 어려움: RDB의 엄격한 스키마로 인해 수평적 확장이 어렵다. RDB는 일반적으로 여러 테이블이 한 서버에 존재하며 이로인해 해당 서버에 디스크 I/O 및 네트워크 부하가 생기면서 성능 저하를 발생시킬 수 있다.

- **NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.**
  - 답변: 정확한 데이터 구조가 정해지지 않은 경우, 데이터 update가 자주 이루어지지 않고 조회가 많은 경우, scale out이 가능하므로 데이터 양이 매우 많은 경우에 사용하면 좋다.

### **3. 트랜잭션이 무엇이고, 3.ACID 원칙에 대해 설명해 주세요.**

- **ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?**

redo log를 통해 보장. 트랜잭션이 수행될 때 변경 내역을 리두 로그에 저장한다. 리두 로그는 비휘발성 저장소에 저장되어서 시스템이 갑작스런 장애로 중단되어도 유지된다. 이후 장애 발생시 리두 로그를 이용해서 변경사항을 복원함으로써 durability를 지킨다.


- **트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?**

반드시 여러 쿼리문을 하나의 논리적 작업으로 묶어서 실행할 때 사용할 수 있다. 예를 들어 정기 구독 신청 기능을 구현할 때, DB에 결제 영수증 정보도 추가해야했고, 배송 정보도 추가해야했다. 만약 기능 실행 중 어떤 문제로 인해 트랜잭션이 롤백 됐을때 배송 정보만 롤백되고 영수증 정보는 DB에 저장한다면 데이터 정합성 문제가 발생하므로 이 두 데이터는 모두 저장되거나 모두 롤백돼야한다. 따라서 이런 결제 로직을 트랜잭션으로 묶어서 처리했었다.

- **읽기에는 트랜잭션을 걸지 않아도 될까요?**
일반적으로 단일 읽기에서는 걸지 않아도 되지만, 복수의 읽기 작업 시 두 읽기에서 일관된 데이터를 읽어야 할 때, 다른 트랜잭션으로 인해 데이터가 변경되는 것을 방지할 수 있다.

### **4. 트랜잭션 격리 레벨에 대해 설명해 주세요.**

- **모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?**
- **만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.**

undo 영역: insert, update, delete와 같은 DML로 데이터를 변경했을 때 변경되지 전의 데이터를 보관하는 곳. MySQL에서는 MVCC를 구현하는 데 사용되며 같은 트랜잭션에서의 일관된 읽기를 지원한다. 그리고 트랜잭션이 롤백될 때 undo 로그의 데이터로 되돌려 놓게 된다.

redo 영역: 커밋된 트랜잭션의 변경 내역을 저장해서 시스템 장애 발생 시 복구할 수 있도록 한다.


- **그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?**

실제 데이터를 **디스크에 저장**하거나 **디스크로부터 데이터를 읽어오는 역할**을 수행한다. 각 스토리지 엔진마다 트랜잭션을 처리하는 방식에 차이가 있다. 예를 들어 MySQL의 InnoDB는 트랜잭션을 지원하지만, MyISAM의 경우 트랜잭션을 지원하지 않는다.

### **5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**

- **일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?**
- **앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?**
- **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**
- **기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?**
- **그렇다면 외래키는요?**
- **인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?**
- **우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?**
- **(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?**

### **6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.**

- **이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?**
- **마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?**
- **다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.**
- **샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?**

### **7. 정규화가 무엇인가요?**

- **정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.**
- **각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.**
- **정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.**

### **8. View가 무엇이고, 언제 사용할 수 있나요?**

- **그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?**

### **9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**

- **사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.**
- **그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?**
- **앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?**
- **3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.**

### **10. B-Tree와 B+Tree에 대해 설명해 주세요.**

- **그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**
- **DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?**
- **오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.**

### **11. DB Locking에 대해 설명해 주세요.**

- **Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.**

  답변:
  - Optimistic Lock: 트랜잭션 간의 충돌이 발생하지 않는다고 가정하고 사용하는 locking 전략이다. 실제로 락을 거는 것이 아닌, 데이터 수정 시의 버전 번호나 타임 스탬프를 비교하여 커밋할지 롤백할지 여부를 결정한다. 충돌이 자주 일어나는 환경에서는 롤백이 자주 일어나서 비효율적이다.
  - Pessimistic Lock: 데이터베이스에 실제로 락을 거는 방식으로, 트랜잭션 간의 충돌이 빈번하게 일어난다고 가정하고 사용하는 방식이다. 트랜잭션이 실행될 때 s-lock(shared lock, 공유락), 또는 x-lock(exclusive lock, 배타락)을 걸어 동시성을 제어한다. 실제 락을 걸어 데이터 접근을 제어하는 방식이기에 시스템 성능에는 좋지 않다.

- **물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?**

  답변: 
  InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있다.
  데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해서 교착 상태에 빠진 트랜잭션들을 찾아 그 중 하나를 강제 종료한다. (언두 로그를 확인하여 변경사항의 개수가 더 적은, 즉 레코드가 더 적은 트랜잭션을 종료한다.)
  또는 Lock wait timeout을 설정하여 무한정 대기하지 않도록 하는 것이 가능하다.

### **12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?**

- **DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?**

### **13. Schema가 무엇인가요?**
  Answer:
    데이터베이스의 구조와 제약에 대한 전반적인 명세를 의미합니다. 데이터베이스를 구성하는 데이터 개체(entity), 속성(Attribute), 관계(relationship), 칼럼들이 갖는 제약 조건 등에 대해 전반적으로 명시한 것입니다.
      사용자 관점에 따라서 외부 스키마, 개념 스키마, 내부 스키마로 나눌 수 있습니다.

- **Schema의 3계층에 대해 설명해 주세요.**
  Answer:
  - 외부 스키마: 사용자나 프로그래머 관점에서 본 스키마입니다. 간단하게 말하면 사용자가 쿼리를 날려서 보게되는 데이터, 테이블 그 자체를 의미합니다.
  - 개념 스키마: 일반적으로 스키마라고 하면 개념 스키마를 의미합니다. 설계자 관점에서 본 스키마로, 전체 데이터베이스 내의 규칙과 구조(여러 엔티티 간의 관계 등)를 표현합니다.
  - 내부 스키마: 개념 스키마의 물리적 저장구조를 나타내는 스키마로, 데이터가 실제로 DB에 저장될 때 데이터 항목의 내부 레코드 형식, 물리적 순서 등을 나타냅니다. 이는 시스템 설계자의 관점에서 보는 스키마입니다.

### **14. DB의 Connection Pool에 대해 설명해 주세요.**
  
    답변: 데이터베이스 커넥션 풀(Database Connection Pool)은 데이터베이스와의 연결(Connection)을 미리 여러 개 생성해두고, 필요할 때마다 이를 재사용하는 기술이다. (매번 데이터베이스 연결을 새로 생성하는 것은 시간과 자원을 많이 소모하기 때문)

    애플리케이션과 데이터베이스 간의 연결은 네트워크를 통해 이루어지며, 이 과정에서 TCP/IP 핸드셰이크와 같은 여러 단계를 거쳐야한다.
    이러한 과정은 연결을 맺는 데 상당한 시간을 소모한다.

    따라서 데이터베이스 커넥션 풀을 사용하면 미리 생성해 둔 연결을 재사용함으로써 연결 생성에 소요되는 시간을 절약하고 애플리케이션의 성능을 향상 시킬 수 있다.

    #### 데이터데이스 커넥션 풀의 구성 요소
    데이터베이스 커넥션 풀은 주로 최소 연결 수(min), 최대 연결 수(max), 연결 대기 시간(timeout)등의 설정으로 구성된다.
    최소 연결 수는 풀이 관리하는 연결의 최소 개수를 의미하며, 애플리케이션 서버가 시작될 때 이 수만큼의 연결이 미리 생성된다. 이는 애플리케이션의 초기 응답 속도를 높이는데 도움이 된다.
    최대 연결 수는 풀이 관리할 수 있는 연결의 최대 수를 의미하며 이 값은 동시에 처리할 수 있는 요청 수와 직접적으로 연관이 있다.
    너무 낮게 설정하면 동시 요청이 많을 때 응답시간이 길어질 수 있고, 너무 높게 설정하며 불필요한 자원을 소모할 수 있다.
    연결 대기 시간은 풀에서 사용 가능한 연결을 기다리는 최대 시간을 의미한다. 이 시간이 초과 되면 예외가 발생한다. 

    ### 데이터베이스 커넥션 풀의 성능을 최적화하는 전략
    - 애플리케이션의 실제 트래픽 패턴을 분석하여 최소 연결 수와 최대 연결 수를 적절하게 설정
    - 유휴 연결 검사와 연결 유효성 검사를 활성화하여 불필요하게 자원을 소모하는 연결을 정리하고 유효한 연결만을 유지 -> 애플리케이션의 안정성을 높이는데 도움이 된다.
    - 성능 모니터링 도구를 사용해서 커넥션 풀의 상태를 지속적으로 모니터링. 필요시에 설정 조정

- **DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.**
  reference: https://orange-makiyato.tistory.com/85

1. 드라이버 로드. DB 종류에 맞는 드라이버를 로드한다.
2. 데이터베이스 계정 연결. DriverManager.getConnection() 메서드로 Connection 객체를 생성해준다.
3. SQL문 실행을 위한 객체 생성
4. SQL문 실행
5. DB 연결 해제(리소스 반납)

### **15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**

- **가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?**
- **COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(\*), COUNT(column) 의 동작 과정에는 차이가 있나요?**

### **16. SQL Injection에 대해 설명해 주세요.**

- 답변: SQL injection이란 악의적인 사용자가 보안상의 취약점을 이용하여 임의의 SQL문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위이다.


#### 공격 종류 및 방법

- Error based SQL Injection: 논리적 에러를 이용한 SQL Injection. 가장 많이 쓰이고 대중적인 공격 기법이다. 주로 OR 1=1 이라는 구문을 끼워넣어 모든 데이터를 조회하게 함
- Union Based SQL Injection: SQL에서 Union 키워드는 두개의 쿼리문에 대한 결과를 통합해서 하나의 테이블로 보여주게하는 키워드이다. 정상적인 쿼리문에 union 키워드를 사용하여 인젝션에 성공하면 원하는 쿼리문을 실행할 수 있다. union injection에 성공하려면 두 테이블의 컬럼수가 같아야하고, 데이터 형이 같아야한다.
- Blind SQL injection > Boolean based SQL: Blind SQL injection은 데이터베이스로부터 특정한 값이나 데이터를 전달받지 않고, 단순히 참과 거짓의 정보만 알 수 있을 때 사용한다. 아래 사진은 Blind Injection을 이용하여 데이터베이스의 테이블 명을 알아내는 예시.
[!blind injection](./assets/blind.png)

- Blind SQL injection > Time based SQL: 서버로부터 특정한 응답 대신에 참 혹은 거짓의 응답을 통해 데이터베이스의 정보를 유추하는 기법. MySQL 기준으로 SLEEP, BENCHMARK를 많이 사용한다.

- Stored Procedure SQL Injection: 저장 프로시저는 일련의 쿼리들을 모아 하나의 함수처럼 사용하기 위한 것이다. 공격에 사용되는 대표적인 저장 프로시저는 MS-SQL에 있는 xp_cmdshell로 윈도우 명령어를 사용할 수 있게 된다. 단, 공격자가 시스템 권한을 획득해야 하므로 공격난이도가 높으나, 공격에 성공한다면 서버에 직접적인 피해를 입힐 수 있다.

- Mass SQL Injection: 기존 SQL Injection 공격과 달리 다량의 데이터베이스가 조작되어 큰 피해를 입히는 것을 의미한다. 보통 MS-SQL을 사용하는 ASP 기반 웹 애플리케이션에서 많이 사용되며 쿼리문은 HEX 인코딩 방식으로 인코딩하여 공격한다. 보통 데이터베이스 값을 변조하여 데이터베이스에 악성스크립트를 삽입하고, 사용자들이 변조된 사이트에 접속 시 좀비 PC로 감염되게 한다. 이렇게 감염된 좀비 PC들은 DDoS 공격에 사용된다.


https://noirstar.tistory.com/264

- **그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?**

  - 답변: ORM 프레임워크의 경우 Prepared Statement를 자동으로 사용한다.
    - 특수 문자를 자동으로 이스케이프처리한다. 즉, `\`를 특수문자 앞에 붙여서 해당 문자를 일반 문자로 취급하도록 만든다.
    - 타입 캐스팅을 강제하여 입력값을 검증한다. 예를 들어 '2024-10-29'가 들어왔을 때, 날짜 타입으로 변환한다.